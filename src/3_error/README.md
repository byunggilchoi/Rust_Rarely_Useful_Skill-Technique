# 에러를 처리하는 여러가지 방법들

계속 에러가 뜨면 혈압이 오른다. 특히 에러 때문에 에러가 뜨면 심각하게 혈압이 오릅니다.

이번 장에서는 러스트의 수많은 에러 처리 방법들을 알아본 후에 실무적으로 사용하기 좋은 방식들을 정리해볼 것입니다.
이 장은 [블로그글](http://www.sheshbabu.com/posts/rust-error-handling/)의 구성을 많이 참고했습니다. 예시 코드도 일부 사용했습니다.

아래에 나오는 대부분의 방법은 match를 이용한 코드로 변환할 수 있습니다. 가급적이면 match 구문으로 변환한것도 같이 넣었습니다.
유용한 매크로와 다양한 숏컷 메서드들이 있는 것은 러스트의 장점이기도 하고 또 남의 코드를 읽는 입장에서 가장 큰 장벽이기도 합니다.(저는 장벽이라는 입장입니다...) 알아두시면 남의 코드를 읽을 때 도움이 되리라고 생각합니다.

[러스트 북](https://doc.rust-lang.org/book/ch09-00-error-handling.html)에서는 초기에 회복할 수 없는 에러와 회복할 수 있는 에러로 나눠서 설명을 하고 있습니다. 문제는 모듈화된 코드를 작성한 후에 에러 핸들링을 따로 다루지 않는 겁니다. 그래서 "북"을 보고 나서도 에러핸들링을 하려면 갑갑해지죠.(제가 그랬다고요...)

이 문서에서는 독자들이 "북"을 다 봤다고 가정하고 아래와 같이 나눠서 설명하겠습니다.

- 에러가 발생한 함수에서 에러를 처리하는 경우(튜토리얼같은 아주 가벼운 프로그램)
- 에러가 발생한 함수의 상위 함수에서 에러를 처리하는 경우(보통의 프로그램)

## 대원칙

- 일반적으로 러스트 함수의 결과값은 Result 타입 사용.
  - 기본적인 Result타입 즉 std::result::Result<T, E>는 enum이고
    - T에는 모든 타입이 올 수 있고
    - E에는 std:error::Error trait을 구현한 타입은 모두 올 수 있음
  - 일반적으로 프로젝트에서는 Error trait을 구현한 자체 Error 타입과 Result 타입을 래핑한 자체 Result 타입을 사용
- 자체 Error, Result 타입을 만드는 방식을 자동화시키는 크레이트들이 있고 그 중 대표적인 것이 `error_chain`.
  - 러스트 쿡북에서도 모두 이 방식을 적용
    그냥 귀찮으면 여기까지만 알면 됩니다.

하지만 이 책을 쓰는 건 그런 목적이 아니니까 더 정리해보죠.

- 러스트의 에러 처리 방식은 크게 두 가지
  - 에러가 발생하면 당장 프로그램을 종료(panic!)
  - 에러가 발생해도 당장 종료하지는 않음(Result<T, E>의 E에 에러를 넣어서 반환)
- 앞에서 말했듯이 일반적인 프로젝트에서는 Result 타입 사용
- panic!은 꽤 편하지만 제대로 무언가를 만들려면 안 쓰게 됨
  - 여러 가지 문제가 있으며
-
- 여러 자료를 봤을 때 가장 일반적인 방법은 error_chain 크레이트를 사용해서 Error와 Result를 필요할 때마다 지정해주는 것
