<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>많이 쓰는 방식: error_chain - Rarely Useful Skills &amp; Techniques for Rustaceans</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../1_trait_type/index.html"><strong aria-hidden="true">1.</strong> trait과 type</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1_trait_type/1_keyword_type.html"><strong aria-hidden="true">1.1.</strong> type 키워드</a></li></ol></li><li class="chapter-item expanded "><a href="../2_confusing/index.html"><strong aria-hidden="true">2.</strong> 헷갈리는 개념들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2_confusing/1_self_Self.html"><strong aria-hidden="true">2.1.</strong> self, Self</a></li></ol></li><li class="chapter-item expanded "><a href="../3_error/index.html"><strong aria-hidden="true">3.</strong> error를 처리하는 여러 가지 방법들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3_error/1_error_handling_on_the_function.html"><strong aria-hidden="true">3.1.</strong> 에러가 발생한 함수에서 에러를 처리할 경우</a></li><li class="chapter-item expanded "><a href="../3_error/2_bubbling.html"><strong aria-hidden="true">3.2.</strong> 에러를 해당 함수 밖으로 보내서 처리하는 방법</a></li><li class="chapter-item expanded "><a href="../3_error/3_using_custom_error.html"><strong aria-hidden="true">3.3.</strong> 좀 더 일반적인 프로젝트에서 쓸 수 있는 방법: 커스텀 에러 이용</a></li><li class="chapter-item expanded "><a href="../3_error/4_using_error_chain_crate.html" class="active"><strong aria-hidden="true">3.4.</strong> 많이 쓰는 방식: error_chain</a></li><li class="chapter-item expanded "><a href="../3_error/5_useful_crates.html"><strong aria-hidden="true">3.5.</strong> 에러 처리에 사용하는 다양한 라이브러리들</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rarely Useful Skills &amp; Techniques for Rustaceans</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#많이-쓰는-방식-error_chain" id="많이-쓰는-방식-error_chain">많이 쓰는 방식: error_chain</a></h1>
<p>결과적으로 러스트의 에러 처리는 꽤 귀찮고 반복적인 코드를 계속 만들어야 하는 문제가 있습니다. 프로그래머들이 이런 걸 그냥 둘 리가 없죠. Rustecean(러스트 사용자)들도 당연히 여러 가지 라이브러리를 통해 해결하고 있습니다. 이번 장에서는 그 중에 제가 보기에 가장 편리해 보이는 <a href="https://crates.io/crates/error-chain"><code>error_chain</code></a>을 다뤄보도록 하겠습니다.<a href="https://rust-lang-nursery.github.io/rust-cookbook/">러스트 쿡북</a>에서도 사용하는 걸 봐서는 저만 편리하게 여기는 것 같지는 않네요.(둘 다 <code>rust-lang-nursery</code>에서 관리하는 리포지터리이긴 합니다. 즉 러스트 팀에서 관리하는(했던) 리포지터리입니다.)</p>
<blockquote>
<p><code>rust-lang-nursery</code>는 <a href="https://internals.rust-lang.org/t/rust-lang-nursery-deprecation/11205/3">19년 말에 운영 종료를 선언</a>했습니다. 원래 러스트 레포지터리에 올라가기에 아직 부족하지만 꽤 유용한 크레이트들을 관리하려는 목적으로 2017년 경에 만들어졌는데 crates.io가 활성화되니까 굳이 이걸 따로 관리해야하냐, 일만 많아진다는 의견들이 나왔습니다. 그래서 mdbook 등 주요 레포지터리들은 러스트 레포지터리로 옮겼습니다. 그런데... 쿡북과 error_chain은 옮기지도 않고 문을 닫지도 않았습니다. 2017년 이후 관리자가 없어서 관리가 안 된다는 이야기가 있었으나 2020년부터 다시 업데이트가 시작되었거든요.(그런데 리포지터리를 안 옮기고 있습니다) 그래서 저도 쓰고 있습니다.
솔직히 언제 관리가 끊길 지 잘 모르겠는데 이 정도로 많이 쓰이는 크레이트면 러스트 문법에 넣는게 맞지 않겠나 싶긴 합니다. 러스트는 아직 유저가 적어서 많이 쓰이지만 관리가 안 되는 크레이트들이 심지어 러스트 팀이 운영하는 크레이트에도 종종 있습니다. 관리자에 지원해보세요.</p>
</blockquote>
<h2><a class="header" href="#error_chain-라이브러리의-특징" id="error_chain-라이브러리의-특징">error_chain 라이브러리의 특징</a></h2>
<ul>
<li>간단한 오류처리부터 복잡한 오류처리까지 일관적인 방법을 제공합니다.
<ul>
<li>이게 핵심인데 이건 기본 문법이 해줘야 하는 것 아닌가요...</li>
</ul>
</li>
<li>오류의 원인(Error trait의 cause 메서드)을 체계적으로 관리하게 해줍니다.
<ul>
<li>이것도 기본 문법이 해줘야 하는 것 아닌가요...</li>
</ul>
</li>
</ul>
<p>다시 말씀드리지만 <code>error_chain</code>은 뭔가 어마어마한 것을 제공하지 않습니다. '기본문법에서 왜 이걸 제공하지 않지?'라는 생각이 드는 것들을 제공합니다.</p>
<h3><a class="header" href="#error_chain-매크로" id="error_chain-매크로">error_chain! 매크로</a></h3>
<p><code>error_chain!</code> 매크로는 <code>error_chain</code> 라이브러리의 핵심이라고 할 수 있습니다. 아래 두 가지 기능을 한 방에 제공하기 때문입니다.</p>
<ul>
<li>커스텀 에러 등 반복적으로 생성해야 하는 타입들을 생성</li>
<li>From trait을 해당 커스텀 에러에 구현 -&gt; <code>?</code>연산자 사용 가능</li>
</ul>
<h3><a class="header" href="#error-구조체" id="error-구조체">Error 구조체</a></h3>
<p>커스텀 에러도 Error라고 이름짓는 것은 러스트의 전통이죠. <code>error_chain</code>의 Error 구조체는 아래 두 가지로 구성되어 있는 튜플 구조체입니다.</p>
<ul>
<li>State: 러스트의 기본 Error에서 생성된 내용을 받아주는 역할
<ul>
<li>백트레이스: 에러가 처음 발생했을 때 기록</li>
<li>Error::cause()의 결과물들이 연결된 에러체인: 처음 발생한 에러가 에러를 '버블링'해서 윗단계로 넘겨주면 단계가 올라갈 때마다 내용을 '체인'에 저장</li>
</ul>
</li>
<li>ErrorKind: enum. 에러의 종류를 표시</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ErrorKind {
  Inner(ErrorKind), // 다른 에러체인으로 연결된다는 의미. 매크로에서 links를 쓰면 Inner(ErrorKind).
  Io(Error),        // std::io::Error 타입이라는 의미. 매크로에서 foreign_links를 쓰면 Io(Error).
  Msg(String),      // 간단한 에러로 스트링을 받았을 때의 ErrorKind.
  Custom,           // 그 외의 커스텀 에러를 받았을 때의 ErrorKind.
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#한-번-써봅시다" id="한-번-써봅시다">한 번 써봅시다.</a></h2>
<p>주절주절 말로 써도 사실 코드를 보는게 이해가 훨씬 빠릅니다.</p>
<h3><a class="header" href="#에러타입-선언하기" id="에러타입-선언하기">에러타입 선언하기</a></h3>
<p>에러타입을 선언하기 위해서는 error_chain! 매크로를 사용합니다. 해당 메크로를 사용해서 하나의 파일이나 모듈에 크레이트 전체를 위한 에러 타입을 지정할 수 있습니다. <code>error_chain</code>의 <a href="https://docs.rs/error-chain/">공식문서</a>에 나오는 코드로 살펴보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error_chain! {
    // 아래 types는 기본값입니다. 코딩하지 않아도 자동으로 설정됩니다.
    types {
        Error, ErrorKind, ResultExt, Result;  // 이름을 이렇게 짓는 것은 전통이라고 생각합니다.
    }
    // 에러체인들이 여러 개가 있을 수도 있겠죠. links는 그 에러체인들 사이를 연결하는 방법입니다.
    // 역시 아래 내용은 적지 않아도 됩니다.
    links {
        Another(other_error::Error, other_error::ErrorKind) #[cfg(unix)];
    }
    // error_chain!으로 정의하지 않은 에러들도 있을 수 있습니다. foreign_links는 그러한 에러를 연결하는 방법입니다.
    // 역시 아래 내용은 적지 않아도 됩니다.
    foreign_links {
        Fmt(::std::fmt::Error);
        Io(::std::io::Error) #[cfg(unix)];
    }
    // ErrorKind에 들어갈 내용들을 더 정의할 수도 있습니다.
    // 여기에 정의해두면 ErrorKind에 들어가서 해당 에러 종류를 선택할 수 있습니다.
    // 각각의 에러에서 정해진 description, display 메서드를 사용해서 자체 메시지를 띄울 수 있습니다.
    // 역시 아래 내용은 적지 않아도 됩니다.
    errors {
        InvalidToolchainName(t: String) {
            description(&quot;invalid toolchain name&quot;)
            display(&quot;invalid toolchain name: '{}'&quot;, t)
        }
        UnknownToolchainVersion(v: String) {
            description(&quot;unknown toolchain version&quot;),
            display(&quot;unknown toolchain version: '{}'&quot;, v),
        }
    }
    // skip_msg_variant가 남아있으면 Error::Msg를 사용해서 간단한 메시지를 띄우는 에러를 처리할 수 있습니다.
    skip_msg_variant
    // 커스텀 에러타입들을 나열하면 모두 ErrorKind에 포함됩니다.
    FooError,
    BarError,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#에러-타입-사용하기" id="에러-타입-사용하기">에러 타입 사용하기</a></h3>
<p><code>error_chain</code>에서 만들어준 커스텀 에러를 사용해봅시다. 여기서는 3가지 방법을 사용할 것입니다.</p>
<ul>
<li>.into(): 각 ErrorKind 타입에서 사용할 수 있는 메서드</li>
<li><code>?</code>: 위의 메서드를 단순화한 연산자</li>
<li>bail!: 같은 기능을 좀 더 간결하게 쓸 수 있는 매크로</li>
</ul>
<p>러스트의 문법은 늘 같은 기능을 구현하는 방법이 너무 많다는 느낌이 듭니다.</p>
<h4><a class="header" href="#into-메서드" id="into-메서드">.into() 메서드</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error_chain! {
    errors { FooError }
}

fn foo() -&gt; Result&lt;()&gt; {
    Err(ErrorKind::FooError.into())
}

fn bar() -&gt; Result&lt;()&gt; {
    Err(&quot;bar error!&quot;.into())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>.into()</code> 메서드는 ErrorKind(스트링 포함)를 받아서 매크로에서 정한 Error 타입으로 변환합니다. 보통은 아래와 같이 줄여서 씁니다.</p>
<h4><a class="header" href="#-연산자" id="-연산자">? 연산자</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error_chain! {
    errors { FooError }
}

fn foo() -&gt; Result&lt;()&gt; {
    Ok(Err(ErrorKind::FooError)?)
}

fn bar() -&gt; Result&lt;()&gt; {
    Ok(Err(&quot;bar error!&quot;)?)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>?</code>앞이 에러가 나올 경우에는 매크로에서 정한 Error로 처리하는 겁니다. 에러가 아니면 Ok로 처리하고요.</p>
<h4><a class="header" href="#bail-매크로" id="bail-매크로">bail! 매크로</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error_chain! {
    errors { FooError }
}

fn foo() -&gt; Result&lt;()&gt; {
    if true {
      bail!{ErrorKind::FooError};
    } else {
      Ok(())
    }
}

fn bar() -&gt; Result&lt;()&gt; {
    if true {
      bail!{&quot;bar error!&quot;};
    } else {
      Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>이 예제에서는 엄청난 효과가 있다고 느끼기 힘들지만 match 구문 등에서 사용할 때 꽤 유용합니다. 그리고 직관적이죠. 앞에서는 왜 Ok()로 <code>?</code> 연산자를 둘러싸는지 잘 이해가 안 가니까요. 그럼에도 너무 종류가 많다는 생각은 듭니다.(엄격하게 보면 <code>error_chain</code>이 외부 라이브러리긴 합니다만.)</p>
<h3><a class="header" href="#에러들을-체이닝해봅시다" id="에러들을-체이닝해봅시다">에러들을 체이닝해봅시다.</a></h3>
<p>라이브러리 이름이 <code>error_chain</code>이니까 에러들을 하나씩 쓰는 게 목적은 아니겠죠?</p>
<ul>
<li>Result 타입에서 chain_err() 메서드 사용
<ul>
<li>Result가 Err이면 chain_err은 즉각 인자로 들어온 클로져를 평가해서 ErrorKind로 변환가능한 결과를 반환</li>
</ul>
</li>
<li>Error 타입에서</li>
</ul>
<h2><a class="header" href="#예시1-main에서-에러-다루기" id="예시1-main에서-에러-다루기">예시1: main에서 에러 다루기</a></h2>
<p><code>error_chain</code>을 사용하기에 아주 좋은 사례입니다. 물론 std::io::Error, <code>?</code> 연산자를 쓰면 어렵지 않게 처리가 가능합니다만.</p>
<p>러스트 쿡북의 <a href="https://rust-lang-nursery.github.io/rust-cookbook/errors/handle.html#handle-errors-correctly-in-main">에러 핸들링</a>에서 가져온 예시를 봅시다.</p>
<pre><pre class="playground"><code class="language-rust">use error_chain::error_chain;     // error_chain이 2017년~2019년 동안 관리가 잘 안 되어서 예전 방식의 extern crate을 써놓은 예시들이 꽤 남아있는데 그냥 use쓰면 됩니다.

use std::fs::File;
use std::io::Read;

error_chain!{                     // 매크로를 선언해서 커스텀 타입(Error, Result, ErrorKind, ResultExt)을 만듭니다.
    foreign_links {               // foreign_links를 통해 두 가지 에러를 ErrorKind에 포함시킵니다.
        Io(std::io::Error);
        ParseInt(::std::num::ParseIntError);
    }
}

fn read_uptime() -&gt; Result&lt;u64&gt; {
    let mut uptime = String::new();
    File::open(&quot;/proc/uptime&quot;)?       // 에러 가능 지점1: std::io::Error
      .read_to_string(&amp;mut uptime)?;  // 에러 가능 지점2: std::io::Error

    Ok(uptime
        .split('.')
        .next()                             // 옵션 반환
        .ok_or(&quot;Cannot parse uptime data&quot;)? // 반환된 옵션을 Result로 변환하면서 None이면 에러 반환-&gt;에러 가능 지점3: Err(E)-&gt; 별도의 msg가 없음-&gt;스트링을 받아서 Msg로 가지고 버블링
        .parse()?)                          // 에러 가능 지점4: std::num::ParseIntError
}

fn main() {
    match read_uptime() {
        Ok(uptime) =&gt; println!(&quot;uptime: {} seconds&quot;, uptime), // 아무 에러가 없으면 parse()의 결과에 따라 u64타입의 숫자가 uptime에 들어감
        Err(err) =&gt; eprintln!(&quot;error: {}&quot;, err),              // 위의 네 가지 에러 중 하나가 걸리면 state에 내용을 가지고 올라와서 err에 들어감
    };
}
</code></pre></pre>
<h2><a class="header" href="#예시2-에러의-타입이-바뀌어도-에러가-없어지진-않습니다" id="예시2-에러의-타입이-바뀌어도-에러가-없어지진-않습니다">예시2: 에러의 타입이 바뀌어도 에러가 없어지진 않습니다</a></h2>
<p><code>error_chain</code>을 쓰면 함수에서 에러의 타입을 간단하게 변환할 수 있습니다. 물론 그 전에 ErrorKind에 해당 에러타입을 추가해둬야겠죠.
아래 예시도 러스트 쿡북의 예시를 가져왔습니다. <a href="./3_error/3_using_custom_error.html">앞 장</a>에서 다뤘던 커스텀에러와 똑같은 방법인데 커스텀 에러, 커스텀 Result를 따로 지정하지 않아도 되니 훨씬 간단해집니다.</p>
<pre><pre class="playground"><code class="language-rust">// reqwest를 사용하기 때문에 해당 크레이트를 Cargo.toml에 넣어야합니다.
use error_chain::error_chain;

error_chain! {
    foreign_links {
        Io(std::io::Error);
        Reqwest(reqwest::Error);                  // 이런 식으로 새로운 라이브러리에서 만들어놓은 Error 타입을 추가하면 됩니다.
        ParseIntError(std::num::ParseIntError);
    }
    errors { RandomResponseError(t: String) }     // 만들어 쓰실 커스텀 에러는 여기에 추가하면 됩니다.
}

fn parse_response(response: reqwest::blocking::Response) -&gt; Result&lt;u32&gt; {
  let mut body = response.text()?;                // 에러가능위치1: reqwest::Error
  body.pop();
  body
    .parse::&lt;u32&gt;()
    .chain_err(|| ErrorKind::RandomResponseError(body)) // parse 메서드의 결과물은 Result인데 여기에 .chain_err()를 체이닝했습니다. .chain_err의 인자에 들어간 ErrorKind의 원소가 에러 타입이 됩니다. 에러가능위치2: RandomResponseError
    // map_err 메서드를 써서 아래와 같이 적어도 되겠죠.
    // body
    //  .parse::&lt;u32&gt;()
    //  .map_err(|e| Error::with_chain(e, ErrorKind::RandomResponseError(body)))
}

fn run() -&gt; Result&lt;()&gt; {
  let url =
    format!(&quot;https://www.random.org/integers/?num=1&amp;min=0&amp;max=10&amp;col=1&amp;base=10&amp;format=plain&quot;);
  let response = reqwest::blocking::get(&amp;url)?;         // 에러가능위치3: reqwest::Error
  let random_value: u32 = parse_response(response)?;    // 에러1이나 2가 나왔으면 에러가 나오겠죠. 여기서의 에러타입은 두 개의 타입을 모두 가질 수 있는 Error가 됩니다.
  println!(&quot;a random number between 0 and 10: {}&quot;, random_value);
  Ok(())
}

fn main() {
  if let Err(error) = run() {                                               // run()의 결과가 에러 1, 2, 3 중 하나 때문에 Err(error)일 때
    match *error.kind() {
      ErrorKind::Io(_) =&gt; println!(&quot;Standard IO error: {:?}&quot;, error),       // 에러의 종류를 불러내는 메서드를 써서 *error.kind()가 무엇인지에 따라서 다르게 처리합니다. 앞 장에서 버블링해서 올린 에러를 어떻게 처리할 지를 다룬 내용과 동일한 방식입니다.
      ErrorKind::Reqwest(_) =&gt; println!(&quot;Reqwest error: {:?}&quot;, error),
      ErrorKind::ParseIntError(_) =&gt; println!(&quot;Standard parse int error: {:?}&quot;, error),
      ErrorKind::RandomResponseError(_) =&gt; println!(&quot;User defined error: {:?}&quot;, error),
      _ =&gt; println!(&quot;Other error: {:?}&quot;, error),
    }
  }
}

</code></pre></pre>
<h2><a class="header" href="#복잡한-오류에서-백트레이스-확보하기" id="복잡한-오류에서-백트레이스-확보하기">복잡한 오류에서 백트레이스 확보하기</a></h2>
<p>여러 겹으로 쌓인 에러 체인은 iterator처럼 출력 가능한데 들어간 순서와 반대로 출력됩니다. 스택처럼요.</p>
<pre><pre class="playground"><code class="language-rust">use error_chain::error_chain;
use serde::Deserialize;

use std::fmt;

error_chain! {
    foreign_links {
        Reader(csv::Error);               // 에러 타입에 포함되어야 할 에러를 적습니다
    }
}

#[derive(Debug, Deserialize)]
struct Rgb {
    red: u8,
    blue: u8,
    green: u8,
}

impl Rgb {
    fn from_reader(csv_data: &amp;[u8]) -&gt; Result&lt;Rgb&gt; {
        let color: Rgb = csv::Reader::from_reader(csv_data)
            .deserialize()
            .nth(0)
            .ok_or(&quot;Cannot deserialize the first CSV record&quot;)?  // Option을 Result로 변환. None이면 에러 메시지1 추가
            .chain_err(|| &quot;Cannot deserialize RGB color&quot;)?;     // Result에서 에러가 나올 경우 에러 메시지2 추가

        Ok(color)
    }
}

impl fmt::UpperHex for Rgb {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let hexa = u32::from(self.red) &lt;&lt; 16 | u32::from(self.blue) &lt;&lt; 8 | u32::from(self.green);
        write!(f, &quot;{:X}&quot;, hexa)
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let csv = &quot;red,blue,green
102,256,204&quot;;

    let rgb = Rgb::from_reader(csv.as_bytes())                // 에러1이 발생할 경우 여기서 에러
      .chain_err(|| &quot;Cannot read CSV data&quot;)?;                 // 그러면 여기서 에러 메시지3 추가
    println!(&quot;{:?} to hexadecimal #{:X}&quot;, rgb, rgb);

    Ok(())
}

fn main() {
    if let Err(ref errors) = run() {                          // run()에서 에러가 발생하면
        eprintln!(&quot;Error level - description&quot;);               // 에러 메시지 헤드 출력
        errors
            .iter()
            .enumerate()
            .for_each(|(index, error)| eprintln!(&quot;└&gt; {} - {}&quot;, index, error));  // 에러 메시지 3 출력-&gt;에러 메시지 2 출력 -&gt; 에러메시지 1 출력 -&gt; 기본 에러메시지 출력

        if let Some(backtrace) = errors.backtrace() {
            eprintln!(&quot;{:?}&quot;, backtrace);                     // 백트레이스 나머지가 있으면 여기서 출력(RUST_BACKTRACE=1일 경우)
        }
    }
}

</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../3_error/3_using_custom_error.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../3_error/5_useful_crates.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../3_error/3_using_custom_error.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../3_error/5_useful_crates.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
